/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface SeaportInterfaceInterface extends ethers.utils.Interface {
  functions: {
    "cancel(tuple[])": FunctionFragment;
    "fulfillAdvancedOrder(((address,address,tuple[],tuple[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes),tuple[],bytes32,address)": FunctionFragment;
    "fulfillAvailableAdvancedOrders(tuple[],tuple[],tuple[][],tuple[][],bytes32,address,uint256)": FunctionFragment;
    "fulfillAvailableOrders(tuple[],tuple[][],tuple[][],bytes32,uint256)": FunctionFragment;
    "fulfillBasicOrder((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,bytes32,bytes32,uint256,tuple[],bytes))": FunctionFragment;
    "fulfillBasicOrder_efficient_6GL6yc((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,bytes32,bytes32,uint256,tuple[],bytes))": FunctionFragment;
    "fulfillOrder(((address,address,tuple[],tuple[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes),bytes32)": FunctionFragment;
    "getContractOffererNonce(address)": FunctionFragment;
    "getCounter(address)": FunctionFragment;
    "getOrderHash((address,address,tuple[],tuple[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256))": FunctionFragment;
    "getOrderStatus(bytes32)": FunctionFragment;
    "incrementCounter()": FunctionFragment;
    "information()": FunctionFragment;
    "matchAdvancedOrders(tuple[],tuple[],tuple[],address)": FunctionFragment;
    "matchOrders(tuple[],tuple[])": FunctionFragment;
    "name()": FunctionFragment;
    "validate(tuple[])": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "cancel",
    values: [
      {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      }[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fulfillAdvancedOrder",
    values: [
      {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      },
      {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      BytesLike,
      string
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fulfillAvailableAdvancedOrders",
    values: [
      {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      { orderIndex: BigNumberish; itemIndex: BigNumberish }[][],
      { orderIndex: BigNumberish; itemIndex: BigNumberish }[][],
      BytesLike,
      string,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fulfillAvailableOrders",
    values: [
      {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      { orderIndex: BigNumberish; itemIndex: BigNumberish }[][],
      { orderIndex: BigNumberish; itemIndex: BigNumberish }[][],
      BytesLike,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fulfillBasicOrder",
    values: [
      {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fulfillBasicOrder_efficient_6GL6yc",
    values: [
      {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fulfillOrder",
    values: [
      {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      },
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getContractOffererNonce",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "getCounter", values: [string]): string;
  encodeFunctionData(
    functionFragment: "getOrderHash",
    values: [
      {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getOrderStatus",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "incrementCounter",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "information",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "matchAdvancedOrders",
    values: [
      {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[],
      string
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "matchOrders",
    values: [
      {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[]
    ]
  ): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "validate",
    values: [
      {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[]
    ]
  ): string;

  decodeFunctionResult(functionFragment: "cancel", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fulfillAdvancedOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fulfillAvailableAdvancedOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fulfillAvailableOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fulfillBasicOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fulfillBasicOrder_efficient_6GL6yc",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fulfillOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getContractOffererNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getCounter", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getOrderHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOrderStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "incrementCounter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "information",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "matchAdvancedOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "matchOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "validate", data: BytesLike): Result;

  events: {};
}

export class SeaportInterface extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: SeaportInterfaceInterface;

  functions: {
    cancel(
      orders: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fulfillAdvancedOrder(
      advancedOrder: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      },
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fulfillAvailableAdvancedOrders(
      advancedOrders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      offerFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      considerationFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      maximumFulfilled: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fulfillAvailableOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      offerFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      considerationFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      fulfillerConduitKey: BytesLike,
      maximumFulfilled: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fulfillBasicOrder(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fulfillBasicOrder_efficient_6GL6yc(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fulfillOrder(
      order: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      },
      fulfillerConduitKey: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getContractOffererNonce(
      contractOfferer: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nonce: BigNumber }>;

    getCounter(
      offerer: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { counter: BigNumber }>;

    getOrderHash(
      order: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<[string] & { orderHash: string }>;

    getOrderStatus(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [boolean, boolean, BigNumber, BigNumber] & {
        isValidated: boolean;
        isCancelled: boolean;
        totalFilled: BigNumber;
        totalSize: BigNumber;
      }
    >;

    incrementCounter(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    information(
      overrides?: CallOverrides
    ): Promise<
      [string, string, string] & {
        version: string;
        domainSeparator: string;
        conduitController: string;
      }
    >;

    matchAdvancedOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillments: {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[],
      recipient: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    matchOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      fulfillments: {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    name(
      overrides?: CallOverrides
    ): Promise<[string] & { contractName: string }>;

    validate(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  cancel(
    orders: {
      offerer: string;
      zone: string;
      offer: {
        itemType: BigNumberish;
        token: string;
        identifierOrCriteria: BigNumberish;
        startAmount: BigNumberish;
        endAmount: BigNumberish;
      }[];
      consideration: {
        itemType: BigNumberish;
        token: string;
        identifierOrCriteria: BigNumberish;
        startAmount: BigNumberish;
        endAmount: BigNumberish;
        recipient: string;
      }[];
      orderType: BigNumberish;
      startTime: BigNumberish;
      endTime: BigNumberish;
      zoneHash: BytesLike;
      salt: BigNumberish;
      conduitKey: BytesLike;
      counter: BigNumberish;
    }[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fulfillAdvancedOrder(
    advancedOrder: {
      parameters: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        totalOriginalConsiderationItems: BigNumberish;
      };
      numerator: BigNumberish;
      denominator: BigNumberish;
      signature: BytesLike;
      extraData: BytesLike;
    },
    criteriaResolvers: {
      orderIndex: BigNumberish;
      side: BigNumberish;
      index: BigNumberish;
      identifier: BigNumberish;
      criteriaProof: BytesLike[];
    }[],
    fulfillerConduitKey: BytesLike,
    recipient: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fulfillAvailableAdvancedOrders(
    advancedOrders: {
      parameters: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        totalOriginalConsiderationItems: BigNumberish;
      };
      numerator: BigNumberish;
      denominator: BigNumberish;
      signature: BytesLike;
      extraData: BytesLike;
    }[],
    criteriaResolvers: {
      orderIndex: BigNumberish;
      side: BigNumberish;
      index: BigNumberish;
      identifier: BigNumberish;
      criteriaProof: BytesLike[];
    }[],
    offerFulfillments: {
      orderIndex: BigNumberish;
      itemIndex: BigNumberish;
    }[][],
    considerationFulfillments: {
      orderIndex: BigNumberish;
      itemIndex: BigNumberish;
    }[][],
    fulfillerConduitKey: BytesLike,
    recipient: string,
    maximumFulfilled: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fulfillAvailableOrders(
    orders: {
      parameters: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        totalOriginalConsiderationItems: BigNumberish;
      };
      signature: BytesLike;
    }[],
    offerFulfillments: {
      orderIndex: BigNumberish;
      itemIndex: BigNumberish;
    }[][],
    considerationFulfillments: {
      orderIndex: BigNumberish;
      itemIndex: BigNumberish;
    }[][],
    fulfillerConduitKey: BytesLike,
    maximumFulfilled: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fulfillBasicOrder(
    parameters: {
      considerationToken: string;
      considerationIdentifier: BigNumberish;
      considerationAmount: BigNumberish;
      offerer: string;
      zone: string;
      offerToken: string;
      offerIdentifier: BigNumberish;
      offerAmount: BigNumberish;
      basicOrderType: BigNumberish;
      startTime: BigNumberish;
      endTime: BigNumberish;
      zoneHash: BytesLike;
      salt: BigNumberish;
      offererConduitKey: BytesLike;
      fulfillerConduitKey: BytesLike;
      totalOriginalAdditionalRecipients: BigNumberish;
      additionalRecipients: { amount: BigNumberish; recipient: string }[];
      signature: BytesLike;
    },
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fulfillBasicOrder_efficient_6GL6yc(
    parameters: {
      considerationToken: string;
      considerationIdentifier: BigNumberish;
      considerationAmount: BigNumberish;
      offerer: string;
      zone: string;
      offerToken: string;
      offerIdentifier: BigNumberish;
      offerAmount: BigNumberish;
      basicOrderType: BigNumberish;
      startTime: BigNumberish;
      endTime: BigNumberish;
      zoneHash: BytesLike;
      salt: BigNumberish;
      offererConduitKey: BytesLike;
      fulfillerConduitKey: BytesLike;
      totalOriginalAdditionalRecipients: BigNumberish;
      additionalRecipients: { amount: BigNumberish; recipient: string }[];
      signature: BytesLike;
    },
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fulfillOrder(
    order: {
      parameters: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        totalOriginalConsiderationItems: BigNumberish;
      };
      signature: BytesLike;
    },
    fulfillerConduitKey: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getContractOffererNonce(
    contractOfferer: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getCounter(offerer: string, overrides?: CallOverrides): Promise<BigNumber>;

  getOrderHash(
    order: {
      offerer: string;
      zone: string;
      offer: {
        itemType: BigNumberish;
        token: string;
        identifierOrCriteria: BigNumberish;
        startAmount: BigNumberish;
        endAmount: BigNumberish;
      }[];
      consideration: {
        itemType: BigNumberish;
        token: string;
        identifierOrCriteria: BigNumberish;
        startAmount: BigNumberish;
        endAmount: BigNumberish;
        recipient: string;
      }[];
      orderType: BigNumberish;
      startTime: BigNumberish;
      endTime: BigNumberish;
      zoneHash: BytesLike;
      salt: BigNumberish;
      conduitKey: BytesLike;
      counter: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<string>;

  getOrderStatus(
    orderHash: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [boolean, boolean, BigNumber, BigNumber] & {
      isValidated: boolean;
      isCancelled: boolean;
      totalFilled: BigNumber;
      totalSize: BigNumber;
    }
  >;

  incrementCounter(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  information(
    overrides?: CallOverrides
  ): Promise<
    [string, string, string] & {
      version: string;
      domainSeparator: string;
      conduitController: string;
    }
  >;

  matchAdvancedOrders(
    orders: {
      parameters: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        totalOriginalConsiderationItems: BigNumberish;
      };
      numerator: BigNumberish;
      denominator: BigNumberish;
      signature: BytesLike;
      extraData: BytesLike;
    }[],
    criteriaResolvers: {
      orderIndex: BigNumberish;
      side: BigNumberish;
      index: BigNumberish;
      identifier: BigNumberish;
      criteriaProof: BytesLike[];
    }[],
    fulfillments: {
      offerComponents: { orderIndex: BigNumberish; itemIndex: BigNumberish }[];
      considerationComponents: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[];
    }[],
    recipient: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  matchOrders(
    orders: {
      parameters: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        totalOriginalConsiderationItems: BigNumberish;
      };
      signature: BytesLike;
    }[],
    fulfillments: {
      offerComponents: { orderIndex: BigNumberish; itemIndex: BigNumberish }[];
      considerationComponents: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[];
    }[],
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  name(overrides?: CallOverrides): Promise<string>;

  validate(
    orders: {
      parameters: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        totalOriginalConsiderationItems: BigNumberish;
      };
      signature: BytesLike;
    }[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    cancel(
      orders: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      }[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    fulfillAdvancedOrder(
      advancedOrder: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      },
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    fulfillAvailableAdvancedOrders(
      advancedOrders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      offerFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      considerationFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      maximumFulfilled: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean[],
        ([
          [number, string, BigNumber, BigNumber, string] & {
            itemType: number;
            token: string;
            identifier: BigNumber;
            amount: BigNumber;
            recipient: string;
          },
          string,
          string
        ] & {
          item: [number, string, BigNumber, BigNumber, string] & {
            itemType: number;
            token: string;
            identifier: BigNumber;
            amount: BigNumber;
            recipient: string;
          };
          offerer: string;
          conduitKey: string;
        })[]
      ] & {
        availableOrders: boolean[];
        executions: ([
          [number, string, BigNumber, BigNumber, string] & {
            itemType: number;
            token: string;
            identifier: BigNumber;
            amount: BigNumber;
            recipient: string;
          },
          string,
          string
        ] & {
          item: [number, string, BigNumber, BigNumber, string] & {
            itemType: number;
            token: string;
            identifier: BigNumber;
            amount: BigNumber;
            recipient: string;
          };
          offerer: string;
          conduitKey: string;
        })[];
      }
    >;

    fulfillAvailableOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      offerFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      considerationFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      fulfillerConduitKey: BytesLike,
      maximumFulfilled: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean[],
        ([
          [number, string, BigNumber, BigNumber, string] & {
            itemType: number;
            token: string;
            identifier: BigNumber;
            amount: BigNumber;
            recipient: string;
          },
          string,
          string
        ] & {
          item: [number, string, BigNumber, BigNumber, string] & {
            itemType: number;
            token: string;
            identifier: BigNumber;
            amount: BigNumber;
            recipient: string;
          };
          offerer: string;
          conduitKey: string;
        })[]
      ] & {
        availableOrders: boolean[];
        executions: ([
          [number, string, BigNumber, BigNumber, string] & {
            itemType: number;
            token: string;
            identifier: BigNumber;
            amount: BigNumber;
            recipient: string;
          },
          string,
          string
        ] & {
          item: [number, string, BigNumber, BigNumber, string] & {
            itemType: number;
            token: string;
            identifier: BigNumber;
            amount: BigNumber;
            recipient: string;
          };
          offerer: string;
          conduitKey: string;
        })[];
      }
    >;

    fulfillBasicOrder(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<boolean>;

    fulfillBasicOrder_efficient_6GL6yc(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<boolean>;

    fulfillOrder(
      order: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      },
      fulfillerConduitKey: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getContractOffererNonce(
      contractOfferer: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCounter(offerer: string, overrides?: CallOverrides): Promise<BigNumber>;

    getOrderHash(
      order: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    getOrderStatus(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [boolean, boolean, BigNumber, BigNumber] & {
        isValidated: boolean;
        isCancelled: boolean;
        totalFilled: BigNumber;
        totalSize: BigNumber;
      }
    >;

    incrementCounter(overrides?: CallOverrides): Promise<BigNumber>;

    information(
      overrides?: CallOverrides
    ): Promise<
      [string, string, string] & {
        version: string;
        domainSeparator: string;
        conduitController: string;
      }
    >;

    matchAdvancedOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillments: {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[],
      recipient: string,
      overrides?: CallOverrides
    ): Promise<
      ([
        [number, string, BigNumber, BigNumber, string] & {
          itemType: number;
          token: string;
          identifier: BigNumber;
          amount: BigNumber;
          recipient: string;
        },
        string,
        string
      ] & {
        item: [number, string, BigNumber, BigNumber, string] & {
          itemType: number;
          token: string;
          identifier: BigNumber;
          amount: BigNumber;
          recipient: string;
        };
        offerer: string;
        conduitKey: string;
      })[]
    >;

    matchOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      fulfillments: {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[],
      overrides?: CallOverrides
    ): Promise<
      ([
        [number, string, BigNumber, BigNumber, string] & {
          itemType: number;
          token: string;
          identifier: BigNumber;
          amount: BigNumber;
          recipient: string;
        },
        string,
        string
      ] & {
        item: [number, string, BigNumber, BigNumber, string] & {
          itemType: number;
          token: string;
          identifier: BigNumber;
          amount: BigNumber;
          recipient: string;
        };
        offerer: string;
        conduitKey: string;
      })[]
    >;

    name(overrides?: CallOverrides): Promise<string>;

    validate(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {};

  estimateGas: {
    cancel(
      orders: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fulfillAdvancedOrder(
      advancedOrder: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      },
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fulfillAvailableAdvancedOrders(
      advancedOrders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      offerFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      considerationFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      maximumFulfilled: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fulfillAvailableOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      offerFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      considerationFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      fulfillerConduitKey: BytesLike,
      maximumFulfilled: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fulfillBasicOrder(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fulfillBasicOrder_efficient_6GL6yc(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fulfillOrder(
      order: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      },
      fulfillerConduitKey: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getContractOffererNonce(
      contractOfferer: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCounter(offerer: string, overrides?: CallOverrides): Promise<BigNumber>;

    getOrderHash(
      order: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getOrderStatus(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    incrementCounter(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    information(overrides?: CallOverrides): Promise<BigNumber>;

    matchAdvancedOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillments: {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[],
      recipient: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    matchOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      fulfillments: {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    validate(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    cancel(
      orders: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fulfillAdvancedOrder(
      advancedOrder: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      },
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fulfillAvailableAdvancedOrders(
      advancedOrders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      offerFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      considerationFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      maximumFulfilled: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fulfillAvailableOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      offerFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      considerationFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      fulfillerConduitKey: BytesLike,
      maximumFulfilled: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fulfillBasicOrder(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fulfillBasicOrder_efficient_6GL6yc(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fulfillOrder(
      order: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      },
      fulfillerConduitKey: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getContractOffererNonce(
      contractOfferer: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCounter(
      offerer: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getOrderHash(
      order: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getOrderStatus(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    incrementCounter(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    information(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    matchAdvancedOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillments: {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[],
      recipient: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    matchOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      fulfillments: {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    validate(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
